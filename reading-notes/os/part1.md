# 第一部分：虚拟化

## 第二章：操作系统介绍

操作系统将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。因此，我们有时将操作系统称为虚拟机（virtual machine）

每个进程访问自己的私有虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程（或操作系统本身）的地址空间。对于正在运行的程序，它完全拥有自己的物理内存。

## 第四章：抽象进程

通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟CPU的假象。这就是时分共享（time sharing）CPU技术，允许用户如愿运行多个并发进程。潜在的开销就是性能损失，因为如果CPU必须共享，每个进程的运行就会慢一点。

#### 进程概念

操作系统为正在运行的程序提供的抽象，就是所谓的进程（process）。

进程的机器状态组成部分：

- 内存，即地址空间（address space）。
- 寄存器。一些特殊的寄存器：程序计数器（Program Counter，PC）（有时称为指令指针，Instruction Pointer或IP）告诉我们程序当前正在执行哪个指令；栈指针（stack pointer）和相关的帧指针（frame pointer）用于管理函数参数栈、局部变量和返回地址。
- 持久存储设备。

### 进程创建

1. 将代码和静态数据加载到内存中。
2. 为程序的运行时栈（run-time stack或stack）分配内存。C程序使用栈存放局部变量、函数参数和返回地址。
3. 也可能为程序的堆（heap）分配一些内存。堆用于显式请求的动态分配数据。malloc() 和 free()。
4. 执行与I/O设置相关的其他工作。在UNIX系统中，默认情况下每个进程都有3个打开的文件描述符（filedescriptor），用于标准输入、输出和错误。

### 进程状态

- 运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。
- 就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。
- 阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起I/O请求时，它会被阻塞，因此其他进程可以使用处理器。



## 第五章：进程 API

1. fork()：创建子进程。父进程获得的返回值是创建的子进程 id（PID），子进程获得的返回值是 0，如下图代码：

   ![image-20220901151947965](/Users/tianyou/Library/Application Support/typora-user-images/image-20220901151947965.png)

   

2. wait()：进程一旦调用了wait，就立即阻塞自己，由 wait 自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait 就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。

   如下图，父进程调用 wait()，延迟自己的执行，直到子进程执行完毕。当子进程结束时，wait()才返回父进程。

   ![image-20220901152821930](/Users/tianyou/Library/Application Support/typora-user-images/image-20220901152821930.png)

3. exec()：exec 没有创建新的进程，而是直接将当前运行的程序（以前的p3）替换为不同的运行程序（wc）。子进程执行exec()之后，几乎就像p3.c从未运行过一样。对exec()的成功调用永远不会返回。



```shell
wc p3.c > newfile.txt
```

wc 输出的结果被重定向到 txt 文件中，shell实现结果重定向的方式也很简单，当完成子进程的创建后，shell在调用exec()之前先关闭了标准输出（standard output），打开了文件newfile.txt。这样，即将运行的程序wc的输出结果就被发送到该文件，而不是打印在屏幕上。

unix 管道用的 pipe() 系统调用，一个进程的输出被链接到了一个内核管道（pipe）上（队列），另一个进程的输入也被连接到了同一个管道上。



## 第六章 机制：受限直接执行

受限的直接执行（limited direct execution），通过用户态内核态来实现进程的受限执行，进程需要执行特殊的陷阱（trap）指令以从用户态陷入到内核态来执行 IO 操作或其他受限指令。完成后，操作系统调用一个特殊的从陷阱返回（return-from-trap）指令回到用户态。陷入内核时，各种寄存器因此被保存（进入内核栈），因此从陷阱返回指令可以容易地恢复。

其他进程执行时，操作系统如何重新获取 CPU 的控制权？

1. 协作方式：OS通过等待系统调用，或某种非法操作发生，从而重新获得CPU的控制权。这样无法防止恶意程序一直不进行系统调用（也不出错）从而一直占有 CPU，或者程序在无限循环，操作系统也没办法。
2. 非协作方式：时钟中断（timer interrupt）。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得CPU的控制权。



## 第七章 进程调度：介绍

调度指标：

- T周转时间 = T完成时间 - T到达时间。性能指标。
- T响应时间 = T首次运行 - T到达时间。公平指标。

调度策略：

- FIFO：先进先出。
- SJF：最短任务优先。非抢占。
- STCF：最短完成时间优先。当新工作进入系统，会确定剩余工作和新工作的剩余时间谁最少就调度谁。是 SJF 的抢占版本。
- RR：轮转。在一个时间片内运行一个工作，然后切换到运行队列中的下一个任务，反复执行直到所有任务完成。

SJF、STCF 优化周转时间，对响应时间不利。

RR 优化响应时间，对周转时间不利。



## 第八章 调度：多级反馈队列

MLFQ，多级反馈队列。有多个优先级的队列，并利用反馈信息决定某个工作的优先级。

规则：

1. if A.Priority > B.Priority，运行 A。
2. if A.Priority = B.Priority，轮转运行 A 和 B。
3. 工作进入系统放在最高优先级（最上层队列）。
4. 一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低优先级。（防止 IO 密集型工作一直占有 CPU，或有程序通过运行 99% 的时间片就调用 IO 来欺骗调度程序，这样可以一直占用 CPU。因为之前的规则是如果工作在时间片内主动放弃 CPU 则优先级不变）。
5. 经过一段时间 S，将系统中所有工作重新加入最高优先级队列。（防止 CPU 密集型工作饿死，一直得不到 CPU）。