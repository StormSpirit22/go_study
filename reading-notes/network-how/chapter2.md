## 第二章：用电信号传输 TCP/IP 数据

## 2.1 创建套接字

### 协议栈的内部结构

![协议栈内部结构](/Users/tianyou/Documents/Github/go_study/.go_study/assets/network-how/2.1-1.png)



Socket 库，其中包括解析器，解析器用来向 DNS 服务器发出查询。

浏览器、邮件等一般应用程序收发数据时用 TCP ; DNS 查询等收发较短的控制数据时用 UDP 。

在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是由 IP 来负责的。此外，IP 中还包括ICMP 协议和 ARP 协议。ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。

### 套接字的实体就是通信控制信息

套接字中记录了用于控制通信操作的各种控制信息，比如通信对象的IP地址、端口号、通信操作的进行状态等。协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。

Windows 中可以用 netstat 命令显示套接字内容。

![netstat](/Users/tianyou/Documents/Github/go_study/.go_study/assets/network-how/2.1-2.png)

看上图，比如第 8 行，它表示 PID 为 4 的程序正在使用 IP 地址为 10.10.1.16 的网卡与 IP 地址为 10.10.1.18 的对象进行通信。此外我们还可以看出，本机使用 1031 端口，对方使用 139 端口，而 139 端口是 Windows 文件服务器使用的端口，因此我们就能够看出这个套接字是连接到一台文件服务器的。

在 mac 上我也试了一下 netstat 命令：

![image-20220523154907140](/Users/tianyou/Documents/Github/go_study/.go_study/assets/network-how/2.1-3.png)

mac 下的 netstat 命令结果稍微有点不同，Recv-Q 和 Send-Q 是表示在 socket queue 中有多少数据等待接收或发送。其他的都差不多。

可参考 [Netstat: network analysis and troubleshooting, explained](https://acloudguru.com/blog/engineering/netstat-network-analysis-and-troubleshooting-explained)

### 调用socket时的操作

![消息收发操作](/Users/tianyou/Documents/Github/go_study/.go_study/assets/network-how/2.1-4.png)

创建套接字时，首先分配一个套接字所需的内存空间，然后向其中写入初始状态。

接下来，需要将表示这个套接字的描述符告知应用程序。收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。



## 2.2 连接服务器

连接实际上是通信双方交换控制信息（比如 IP地址和端口），在套接字中记录这些必要信息并准备数据收发的一连串操作。此外，当执行数据收发操作时，还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作的过程中分配的。

### TCP 头

![tcp头部格式](/Users/tianyou/Documents/Github/go_study/.go_study/assets/network-how/2.2-1.png)

以上这些控制信息位于网络包的开头，因此被称为头部。

### 连接操作

调用 Socket 库的 connect 。操作流程里需要 TCP 模块创建表示连接控制信息的头部，并将信息传递给 IP 模块委托它进行发送，然后开始 TCP 的三次握手。



## 2.3 收发数据

### 将HTTP请求消息交给协议栈

当控制流程从 connect 回到应用程序之后，接下来就进入数据收发阶段了。应用程序会将要发送的数据传递给协议栈，而协议栈会将这些数据暂存到内部的发送缓冲区，等待数据积累到一定量时再发送出去。如果来一次数据就发一次，那么可能会发送大量的小包，导致网络效率下降。

MTU：一个网络包的最大长度，以太网中一般为 1500 字节。

MSS：除去头部之后，一个网络包所能容纳的 TCP 数据的最大长度。即 MTU - header_length

几个判断是否可以发送的要素：

- 长度： 当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去。
- 时间：议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去。

也可以通过指定协议栈的选项来控制发送时机，比如不等待直接发送，就会来一次数据就发一次请求。

![MTU与MSS](/Users/tianyou/Documents/Github/go_study/.go_study/assets/network-how/2.3-1.png)

### 拆包

当一次要发送的数据长度超过 MSS 时，就需要 TCP 协议进行拆分，这就是 TCP 拆包。

![应用程序数据的拆分发送](/Users/tianyou/Documents/Github/go_study/.go_study/assets/network-how/2.3-2.png)

### 使用ACK号确认网络包已收到

![序号和ACK号的用法](/Users/tianyou/Documents/Github/go_study/.go_study/assets/network-how/2.3-3.png)

在上图中，序号其实一般不是从 1 开始，而是用随机数计算出一个初始值，这是因为如果序号都从 1 开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。序号是放在 TCP 头部的。

![序号和ACK号的交互](/Users/tianyou/Documents/Github/go_study/.go_study/assets/network-how/2.3-4.png)

如上图， 1、2、3 步都是客户端与服务器建立连接的操作，4、5 是客户端向服务器发送数据的过程，6、7 是服务器向客户端发送数据的过程。

客户端和服务器都需要生成自己的序号初始值发送给对方，对方再计算并返回对应的 ACK 。如果对方没有返回某些包对应的 ACK 号，那么就重新发送这些包。不过如果网络出现故障，TCP 会在尝试几次重传无效之后强制结束通信，并向应用程序报错。

### 根据网络包平均往返时间调整ACK号等待时间

TC P采用了动态调整等待时间的方法，这个等待时间是根据 ACK 号返回所需的时间来判断的。具体来说，TCP 会在发送数据的过程中持续测量 ACK 号的返回时间，如果 ACK 号返回变慢，则相应延长等待时间；相对地，如果 ACK 号马上就能返回，则相应缩短等待时间。这个等待时间也就是超时重传时间，超时时间过了之后 TCP 就会重传对应的包。

### 滑动窗口

滑动窗口，就是在发送一个包之后，不等待ACK号返回，而是直接发送后续的一系列包。

![滑动窗口与接收缓冲区](/Users/tianyou/Documents/Github/go_study/.go_study/assets/network-how/2.3-5.png)

接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口方式的基本思路。

### ACK与窗口的合并

接收方在发送 ACK 号和窗口更新时，并不会马上把包发送出去，而是会等待一段时间，在这个过程中很有可能会出现其他的通知操作，这样就可以把两种通知合并在一个包里面发送了。

同样地，多个 ACK 的更新也可以合并。ACK 号是告诉发送方目前已接收的数据的最后位置在哪里，因此当需要连续发送 ACK 号时，只要发送最后一个 ACK 号就可以了，中间的可以全部省略。窗口更新也是类似。

### 流程总结

首先，协议栈会检查收到的数据块和 TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号。

然后，协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据。

最后将数据交给应用程序。具体来说，协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新