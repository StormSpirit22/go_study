# 第三章：数据存储与检索

最简单的数据库可以用两个 Bash 函数实现：

```bash
#!/bin/bash
db_set () {
  echo "$1,$2" >> database
}

db_get () {
  grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

该数据库会将所有记录追加存储到日志文件中。如果文件越来越大，那么 db_get 的性能也会越来越差，因为每次都要从头到尾扫描整个数据库文件来查找键的出现位置。

## 索引

索引：保留一些额外的元数据，这些元数据作为路标，帮助定位想要的数据。

每次写操作都需要更新索引。适当的索引可以加速读取查询，但每个索引都会减慢写速度。

### 哈希索引

保存内存中的 hash map ，把每个键一一映射到数据文件中特定的字节偏移量 ， 这样就可以找到每个值的位置。

![Bitcask哈希索引](/Users/tianyou/Library/Application Support/typora-user-images/image-20220527092847248.png)

采用追加方式，将日志分解成一定大小的段，当段文件到达一定大小后就关闭它，将日志写入新的段文件中。这样追加写入的方式可以充分利用磁盘的顺序写入特性，性能非常快。

对于关闭冻结的段，可以使用压缩（在日志中丢弃重复的键，只保留最新的键）及合并（将多个压段合并到一起）的方式减少段日志文件的大小和数量，这个过程可以使用后台线程处理。运行时，仍然可以用旧的段文件继续正常读取和写请求。当合并过程完成后，将读取请求切换到新的合并段上，而旧的段文件可以安全删除 。

![压缩合并](/Users/tianyou/Library/Application Support/typora-user-images/image-20220527094523953.png)

哈希表索引的局限性：

- 哈希表必须全部放到内存，如果键特别多会很占用内存。而如果存储到磁盘上，需要大量的随机 IO，速度又特别慢。而且哈希冲突需要复杂的处理逻辑。
- 区间查询的效率不高。

### SSTables 与 LSM-Tree

SSTable（Sorted String Table），排序字符串表。和上面的压缩合并类似，SSTable 也会对多个 SSTable 段进行压缩合并，保证每个键在每个合并的段文件中只能出现一次，当多个段包含相同的键时，可以保留最新段的值，井丢弃旧段中的值。并将 key-value 对的顺序**按键排序**。按键排序的好处是可以在查询的时候将某一块数据用一个稀疏索引来加快查询速度，索引查到这块数据的开头，然后顺序遍历这块数据查询即可。

![压缩合并SSTable](/Users/tianyou/Library/Application Support/typora-user-images/image-20220527100813608.png)

在内存中使用稀疏索引来保存某些键的偏移，加快查询速度。

![稀疏索引](/Users/tianyou/Library/Application Support/typora-user-images/image-20220527100932663.png)

并且如上图所示，可以将某一块的数据进行压缩再写入磁盘中，然后稀疏索引的每个条目指向这个块的开头。这样除了节省磁盘空间，还减少了 IO 带宽的占用。

#### 构建和维护 SSTables

存储引擎的基本工作流程如下 ：

- 当写入时，将其添加到内存中的平衡树数据结构中（例如红黑树）。这个内存中的树有时被称为内存表。

- 当内存表大于某个阈值（通常为几兆字节）时，将其作为 SSTable 文件写入磁盘。由于树已经维护了按键排序的 key - value 对， 写 磁盘可以比较高效。新的 SSTable 文件成为数据库的最新部分。当 SSTable 写磁盘的同时 ，新写入的数据可以继续添加到一个新的内存表实例（SSTable 段）。

- 处理读请求，首先尝试在内存表中查找键，然后是最新的磁盘段文件，接下来是次新的磁盘段文件，以此类推，直到找到目标（或为空）。 
- 后台进程周期性地执行段合并与压缩过程，以合并多个段文件，并丢弃那些已被覆盖或删除的值 。

另外数据在写入内存表之前，会先将数据写入到磁盘上的一个日志文件，该文件不需要任何排序，只是为了当数据库崩溃时可以使用该文件恢复内存表。这也就是 WAL（Write-Ahead Logging）。

#### 从 SSTables 到 LSM -Tree

LevelDB[6] 和 RocksDB[7] 都是使用了上述的算法。类似的存储引擎还被用于 Cassandra 和 HBase[8]。

日志结构的合井树（ Log-Structured Merge-Tree ，或LSM-Tree)，基于**合井和压缩排序文件原理**的存储引擎通常都被称为LSM存储引擎。在 Lucene 中，从词条到 posting list 的映射关系保存在类 SSTable 的排序文件中，这些文件可以根据需要在后台合并[14]。

#### 性能优化

- 当查找数据库中不存在的数据时，LSM-Tree 算法可能会很慢，因为需要遍历内存表以及磁盘里所有的段文件才能确定键不存在。因此我们可以引入布隆过滤器来直接排除一定不存在的 key 。

- 一般有大小分级和分层压缩这两种策略来决定 SSTable 压缩和合并 时的具体顺序和时机。LevelDB 和Rocks DB 使用分层压缩（因此名称为 LevelDB)。分层压缩如下图所示：

  ![img](https://3531624266-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-Mb6AooPskqOLCYT_UHa%2Fuploads%2Fgit-blob-d962155245ab133eecffe4cfc80e5305bf91aa56%2Ftikv-4.png?alt=media)

  HBase 使用大小分级， Cassandra 则同时支持这两种压缩［16］。

  在大小分级的压缩中，较新的和较小的 SSTables 被连续合并到较旧和较大的 SSTables 。在分层压缩中，键的范围分裂成多个更小的SSTables ，旧数据被移动到单独的“层级”，这样压缩可以逐步进行并节省磁盘空间。

#### 小结

LSM-Tree 算法即使数据集远远大于可用内存，它仍然能够正常工 。 由于数据按排序存储，因此可以有效地执行区间查询（从最小值到最大值扫描所有的键），并且由于磁盘是顺序写入的，所以 LSM-tree 可以支持非常高的写入吞吐量。

### B-Trees

LSM-Tree 将数据库分解为可变大小的段，通常大小为几兆字节或更大，并且始终按顺序写入段。相比之下， B -tree将数据库分解成固定大小的块或页， 传统上大小为 4 KB（有时更大），页是内部读／写的最小单元。这种设计更接近底层硬件，因为磁盘也是以固定大小的块排列。

每个页面都可以使用地址或位置进行标识，这样可以让一个页面引用另一个页面，类似指针，不过是指向磁盘地址，而不是内存。可以使用这些页面引用来构造一个树状 页面，如图所示。

![B-tree索引](/Users/tianyou/Library/Application Support/typora-user-images/image-20220527105831926.png)

B-tree 中一个页所包含的子页引用数量称为分支因子。如上图的 B-tree 的分支因子为 6 。在实际中， 分支因素取决于存储页面引用和范围边界所需的空间总量， 通常为几百个。

![插入节点](/Users/tianyou/Library/Application Support/typora-user-images/image-20220527111054911.png)

该插入分裂算法确保树保持平衡 ： 具有 n 个键的 B-tree 总是具有 O (log n）的深度。 大多数数据库可以适合 3~4 层的 B-tree ，因此不需要遍历非常深的页面层次即可找到所需的页（分支因子为 500 的 4KB 页的四级树可以存储高达 256 TB ）。

B-Tree 使用 WAL redo log 来保证能从崩溃中恢复。此外 B+ 树里还有一些优化 B-Tree 的点，这里就不细说了。

### 对比 B-tree 和 LSM-tree

LSM-tree 优点：

- LSM-tree 一般比 B-tree 拥有更好的写入吞吐量。
- LSM-tree 支持更好的压缩，而且由于 B-tree 会频繁的分裂，可能会导致一些磁盘空间无法使用，因此一般 LSM-tree 的磁盘文件要小一些。

LSM-tree 缺点：

- 压缩过程有时会干扰正在进行的读写操作，容易发生读写请求等待的情况。这样 LSM-tree 的查询晌应时间有时会相当高，而B-tree的响应延迟则更具确定性[28]。
- 如果写入吞吐量很高井且压缩没有仔细配置，那么就会发生压缩无法匹配新数据写入速率的情况。这时磁盘上未合并段的数量不断增加，直到磁盘空间不足，并且读的速度也会受影响。
- B-tree 索引可以提供更好的事务语义，因为一个 key 只会出现一个 Page 页里面；由于 LSM 树只能追加写，并且在 L0 层的 SSTable 中会重叠，所以对事务支持较弱，只能在 compaction 的时候进行真正地更新和删除。

### 其他索引结构

聚集索引（在索引中直接保存行数据 ）和非聚集索引（仅存储索引中的数据的引用） 之间有一 种折中设计称为覆盖索引或包含列的索 引，它在索引中保存一些表的列值［33］。它可以支持只通过索引即可回答某些简单查询（在这种情况下，称索引覆盖了查询）[32］。

#### 多列索引

也叫联合索引，符合最左匹配原则。

空间索引，PostGIS使用PostgreSQL 的广义搜索树索引［35］实现了地理空间索引作为R树 。

### 内存数据库

内存数据库的性能优势并不是因为它们不需要从磁盘读取。如果有足够的内存，即使是基于磁盘的存储引 擎 ，也可能永远不需要从磁盘读取，因为操作系统将最近使用的磁盘块缓存在内存中。相反，内存数据库可以更快，是因为它们**避免使用写磁盘的格式对内存数据结构编码的开销**［44］。而且内存数据库的一些数据结构也都进行了相应的优化，比如 Redis。

关注内存型数据库的持久化方案，以及非易失性存储技术的发展（如额外电池供电）。

- 

## 事务处理与分析处理

**OLTP（online transaction processing）**：在线事务处理，交互式的，每次读取少量数据返回用户；上面说的一些 B-tree 、LSM-tree 以及内存数据库都属于该类型。

**OLAP（online analytic processing）**：在线分析处理，不是直接面向客户，每次扫描大量数据，进行分析处理。数据仓库、列式存储都属于该类型。

### 数据仓库

